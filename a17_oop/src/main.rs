/*
 * Rust的面向对象
 *
 */

// =============================== 面向对象语言的特点 ======================
// 面向对象编程语言所共享的一些特性往往是对象、封装和继承。
// 让我们看一下这每一个概念的含义以及 Rust 是否支持他们。

// ------------------------ 对象包含数据和行为 -------------------
// The Gang of Four 定义对象：
// 面向对象的程序是由对象组成的。一个 对象 包含数据和操作这些数据的过程。这些过程通常被称为 方法 或 操作。
//
// Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。
// 虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能。

// ------------------------ 封装隐藏了实现细节 -------------------
// 另一个通常与面向对象编程相关的方面是 封装（encapsulation）的思想：对象的实现细节不能被使用对象的代码获取到。
// 所以唯一与对象交互的方式是通过对象提供的公有API；使用对象的代码无法深入到对象内部并直接改变数据或者行为。
// 封装使得改变和重构对象的内部时无需改变使用对象的代码。

// 就像我们在第七章讨论的那样：可以使用 pub 关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的。
// 注意，结构体自身被标记为 pub，这样其他代码就可以使用这个结构体，但是在结构体内部的字段仍然是私有的。
//
// 如果封装是一个语言被认为是面向对象语言所必要的方面的话，那么 Rust 满足这个要求。
// 在代码中不同的部分使用 pub 与否可以封装其实现细节。
//

// ------------------------- 继承，作为类型系统与代码共享 -----------
// 继承（Inheritance）是一个很多编程语言都提供的机制，
// 一个对象可以定义为继承另一个对象的定义，这使其可以获得父对象的数据和行为，而无需重新定义。

// 如果一个语言必须有继承才能被称为面向对象语言的话，那么 Rust 就不是面向对象的。
// 无法定义一个结构体继承父结构体的成员和方法。
// 然而，如果你过去常常在你的编程工具箱使用继承，根据你最初考虑继承的原因，Rust 也提供了其他的解决方案。

// 选择继承有两个主要的原因。
// 第一个是为了重用代码：一旦为一个类型实现了特定行为，继承可以对一个不同的类型重用这个实现。
// 相反 Rust 代码可以使用默认 trait 方法实现来进行共享，在示例中我们见过在 Summary trait 上增加的 summarize 方法的默认实现。
// 任何实现了 Summary trait 的类型都可以使用 summarize 方法而无须进一步实现。
// 这类似于父类有一个方法的实现，而通过继承子类也拥有这个方法的实现。
// 当实现 Summary trait 时也可以选择覆盖 summarize 的默认实现，这类似于子类覆盖从父类继承的方法实现。

// 第二个使用继承的原因与类型系统有关：表现为子类型可以用于父类型被使用的地方。
// 这也被称为 多态（polymorphism），这意味着如果多种对象共享特定的属性，则可以相互替代使用。
//
// 多态（Polymorphism）
// 很多人将多态描述为继承的同义词。不过它是一个有关可以用于多种类型的代码的更广泛的概念。
// 对于继承来说，这些类型通常是子类。
// Rust 则通过泛型来对不同的可能类型进行抽象，并通过 trait bounds 对这些类型所必须提供的内容施加约束。
// 这有时被称为 bounded parametric polymorphism。
//
// 近来继承作为一种语言设计的解决方案在很多语言中失宠了，因为其时常带有共享多于所需的代码的风险。
// 子类不应总是共享其父类的所有特征，但是继承却始终如此。
// 如此会使程序设计更为不灵活，并引入无意义的子类方法调用，或由于方法实际并不适用于子类而造成错误的可能性。
// 某些语言还只允许子类继承一个父类，进一步限制了程序设计的灵活性。

// 因为这些原因，Rust 选择了一个不同的途径，使用trait对象而不是继承。
// 让我们看一下 Rust 中的 trait 对象是如何实现多态的。

// =============================== 为使用不同类型的值而设计的trait对象 ======================
// 在第八章中，我们谈到了 vector 只能存储同种类型元素的局限。
// 示例中提供了一个定义 SpreadsheetCell 枚举来储存整型，浮点型和文本成员的替代方案。
// 这意味着可以在每个单元中储存不同类型的数据，并仍能拥有一个代表一排单元的 vector。
// 这在当编译代码时就知道希望可以交替使用的类型为固定集合的情况下是完全可行的。
//
// 然而有时我们希望库用户在特定情况下能够扩展有效的类型集合。

// ----------------- 定义通用行为的trait ----------------------------
// 我们可以使用 trait 对象代替泛型或具体类型。
// 任何使用 trait 对象的位置，Rust 的类型系统会在编译时确保任何在此上下文中使用的值会实现其 trait 对象的 trait。
// 如此便无需在编译时就知晓所有可能的类型。
//
// 之前提到过，Rust 刻意不将结构体与枚举称为 “对象”，以便与其他语言中的对象相区别。
// 在结构体或枚举中，结构体字段中的数据和 impl 块中的行为是分开的，不同于其他语言中将数据和行为组合进一个称为对象的概念中。
// trait 对象将数据和行为两者相结合，从这种意义上说则其更类似其他语言中的对象。
// 不过 trait 对象不同于传统的对象，因为不能向 trait 对象增加数据。
// trait 对象并不像其他语言中的对象那么通用：其（trait 对象）具体的作用是允许对通用行为进行抽象。

mod demo {
    pub trait Draw {
        fn draw(&self);
    }

    pub struct Screen {
        // 这个 vector 的类型是Box<dyn Draw>，
        // 此为一个 trait 对象：它是Box中任何实现了 Draw trait 的类型的替身。
        //
        // 这与定义使用了带有 trait bound 的泛型类型参数的结构体不同。
        // 泛型类型参数一次只能替代一个具体类型，而 trait 对象则允许在运行时替代多种具体类型。
        //
        // 当编写库的时候，我们不知道何人会在何时增加 SelectBox 类型，不过 Screen 的实现能够操作并绘制这个新类型，
        // 因为SelectBox 实现了 Draw trait，这意味着它实现了 draw 方法。
        // 这个概念 —— 只关心值所反映的信息而不是其具体类型 —— 
        // 类似于动态类型语言中称为鸭子类型（duck typing）的概念：
        // 如果它走起来像一只鸭子，叫起来像一只鸭子，那么它就是一只鸭子！
        // 在示例中Screen 上的 run 实现中，run 并不需要知道各个组件的具体类型是什么。
        // 它并不检查组件是 Button 或者 SelectBox 的实例。
        // 通过指定 Box<dyn Draw> 作为 components vector 中值的类型，
        // 我们就定义了 Screen 为需要可以在其上调用 draw 方法的值。
        //
        // 使用 trait 对象和 Rust 类型系统来进行类似鸭子类型操作的优势是:
        //   无需在运行时检查一个值是否实现了特定方法或者担心在调用时因为值没有实现方法而产生错误。
        //   如果值没有实现 trait 对象所需的 trait 则 Rust 不会编译这些代码。
        pub components: Vec<Box<dyn Draw>>,
    }

    impl Screen {
        pub fn run(&self) {
            for component in self.components.iter() {
                component.draw();
            }
        }
    }

    pub struct Button {
        pub width: i32,
        pub height: i32,
        pub label: String,
    }
    impl Draw for Button {
        fn draw(&self) {
            println!("Button");
        }
    }
    pub struct SelectBox {
        pub width: u32,
        pub height: u32,
        pub options: Vec<String>,
    }

    impl Draw for SelectBox {
        fn draw(&self) {
            println!("SelectBox");
        }
    }
}

use self::demo::{Button, Screen, SelectBox};
fn show_screen() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };
    screen.run();
}

// 使用泛型实现
mod generic {
    pub trait Draw {
        fn draw(&self);
    }
    pub struct Screen<T: Draw> {
        pub components: Vec<T>,
    }

    impl<T> Screen<T>
    where
        T: Draw,
    {
        pub fn run(&self) {
            for component in self.components.iter() {
                component.draw();
            }
        }
    }
}

// ------------------ trait 对象执行动态分发 ---------------
// 回忆一下第十章 “泛型代码的性能” 部分讨论过的，当对泛型使用 trait bound 时编译器所进行单态化处理：
// 编译器为每一个被泛型类型参数代替的具体类型生成了非泛型的函数和方法实现。
// 单态化所产生的代码进行静态分发（static dispatch）。
// 静态分发发生于编译器在编译时就知晓调用了什么方法的时候。
// 这与动态分发（dynamic dispatch）相对, 这时编译器在编译时无法知晓调用了什么方法。
// 在动态分发的情况下，编译器会生成在运行时确定调用了什么方法的代码。
//
// 当使用trait 对象时，Rust 必须使用动态分发。
// 编译器无法知晓所有可能用于trait对象代码的类型，所以它也不知道应该调用哪个类型的哪个方法实现。
// 为此，Rust在运行时使用trait对象中的指针来知晓需要调用哪个方法。
// 动态分发也阻止编译器有选择的内联方法代码，这会相应的禁用一些优化。
// 尽管在编写示例17-5 和可以支持示例 17-9 中的代码的过程中确实获得了额外的灵活性，但仍然需要权衡取舍。

// ------------------ Trait 对象要求对象安全 --------------
// 只有对象安全object safe的trait 才可以组成 trait 对象。
// 围绕所有使得trait对象安全的属性存在一些复杂的规则，不过在实践中，只涉及到两条规则。
// 如果一个 trait 中所有的方法有如下属性时，则该 trait 是对象安全的：
//  1. 返回值类型不为 Self
//  2. 方法没有任何泛型类型参数
//
// Self 关键字是我们要实现trait或方法的类型的别名。
// 对象安全对于 trait 对象是必须的，因为一旦有了 trait 对象，就不再知晓实现该 trait 的具体类型是什么了。
// 如果trait 方法返回具体的 Self 类型，但是 trait 对象忘记了其真正的类型，那么方法不可能使用已经忘却的原始具体类型。
// 同理对于泛型类型参数来说，当使用 trait 时其会放入具体的类型参数：此具体类型变成了实现该 trait 的类型的一部分。
// 当使用 trait 对象时其具体类型被抹去了，故无从得知放入泛型参数类型的类型是什么。
//
// 一个 trait 的方法不是对象安全的例子是标准库中的 Clone trait。
// Clone trait 的 clone 方法的参数签名看起来像这样：

mod no_object_safe {
    pub trait Clone {
        fn clone(&self) -> Self;
    }

    // 如果尝试做一些违反有关 trait 对象的对象安全规则的事情，编译器会提示你。
    // 例如，如果尝试实现示例 17-4 中的 Screen 结构体来存放实现了 Clone trait 而不是 Draw trait 的类型，像这样：
    pub struct Screen {
        // 这意味着不能以这种方式使用此 trait 作为 trait 对象
        // pub components: Vec<Box<dyn Clone>>,
    }
}


// =============================== 面向对象设计模式的实现 ======================
// 状态模式（state pattern）是一个面向对象设计模式。
// 该模式的关键在于一个值有某些内部状态，体现为一系列的 状态对象，同时值的行为随着其内部状态而改变。
// 状态对象共享功能：当然，在 Rust 中使用结构体和 trait 而不是对象和继承。
// 每一个状态对象代表负责其自身的行为和当需要改变为另一个状态时的规则的状态。
// 持有任何一个这种状态对象的值对于不同状态的行为以及何时状态转移毫不知情。

// 使用状态模式意味着当程序的业务需求改变时，无需改变值持有状态或者使用值的代码。
// 我们只需更新某个状态对象中的代码来改变其规则，或者是增加更多的状态对象。
// 让我们看看一个有关状态模式和如何在 Rust 中使用它的例子。
//
// 为了探索这个概念，我们将实现一个增量式的发布博文的工作流。这个博客的最终功能看起来像这样：
//   1. 博文从空白的草案开始。
//   2. 一旦草案完成，请求审核博文。
//   3. 一旦博文过审，它将被发表。
//   4. 只有被发表的博文的内容会被打印，这样就不会意外打印出没有被审核的博文的文本。
//
// 任何其他对博文的修改尝试都是没有作用的。
// 例如，如果尝试在请求审核之前通过一个草案博文，博文应该保持未发布的状态。

mod blog;
use blog::Post;

fn deal_blog() {
    // 草案
    let mut post = Post::new();

    // 添加内容
    post.add_text("I ate a salad for lunch today");
    assert_eq!("", post.content());

    // 请求审核
    post.request_review();
    assert_eq!("", post.content());

    // 审核通过
    post.approve();
    assert_eq!("I ate a salad for lunch today", post.content());
}

// ----------- 状态模式的权衡取舍 -----------------
// 我们展示了 Rust 是能够实现面向对象的状态模式的，以便能根据博文所处的状态来封装不同类型的行为。
// Post 的方法并不知道这些不同类型的行为。
// 通过这种组织代码的方式，要找到所有已发布博文的不同行为只需查看一处代码：Published 的 State trait 的实现。

// 如果要创建一个不使用状态模式的替代实现，则可能会在 Post 的方法中，或者甚至于在 main 代码中用到 match 语句，
// 来检查博文状态并在这里改变其行为。
// 这意味着需要查看很多位置来理解处于发布状态的博文的所有逻辑！
// 这在增加更多状态时会变得更糟：每一个 match 语句都会需要另一个分支。

// 对于状态模式来说，Post 的方法和使用 Post 的位置无需 match 语句，
// 同时增加新状态只涉及到增加一个新 struct 和为其实现 trait 的方法。

// 这个实现易于扩展增加更多功能。为了体会使用此模式维护代码的简洁性，请尝试如下一些建议：

//   1. 增加 reject 方法将博文的状态从 PendingReview 变回 Draft
//   2. 在将状态变为 Published 之前需要两次 approve 调用
//   3. 只允许博文处于 Draft 状态时增加文本内容。提示：让状态对象负责什么可能会修改内容而不负责修改 Post。

// 缺点：
// 状态模式的一个缺点是因为状态实现了状态之间的转换，一些状态会相互联系。
// 如果在 PendingReview 和 Published 之间增加另一个状态，比如 Scheduled，
// 则不得不修改 PendingReview 中的代码来转移到 Scheduled。
// 如果 PendingReview 无需因为新增的状态而改变就更好了，不过这意味着切换到另一种设计模式。
//
// 另一个缺点是我们会发现一些重复的逻辑。
// 为了消除他们，可以尝试为 State trait 中返回 self 的 request_review 和 approve 方法增加默认实现，
// 不过这会违反对象安全性，因为 trait 不知道 self 具体是什么。
// 我们希望能够将 State 作为一个 trait 对象，所以需要其方法是对象安全的。

// 另一个重复是 Post 中 request_review 和 approve 这两个类似的实现。
// 他们都委托调用了 state 字段中 Option 值的同一方法，并在结果中为 state 字段设置了新值。
// 如果 Post 中的很多方法都遵循这个模式，我们可能会考虑定义一个宏来消除重复（查看第十九章的 “宏” 部分）。

// 完全按照面向对象语言的定义实现这个模式并没有尽可能地利用 Rust 的优势。
// 让我们看看一些代码中可以做出的修改，来将无效的状态和状态转移变为编译时错误。

// ...


// 总结：
// 阅读本章后，不管你是否认为 Rust 是一个面向对象语言，
// 现在你都见识了 trait 对象是一个 Rust 中获取部分面向对象功能的方法。
// 动态分发可以通过牺牲少量运行时性能来为你的代码提供一些灵活性。
// 这些灵活性可以用来实现有助于代码可维护性的面向对象模式。
// Rust 也有像所有权这样不同于面向对象语言的功能。
// 面向对象模式并不总是利用 Rust 优势的最好方式，但也是可用的选项。


fn main() {
    show_screen();
    deal_blog();
}
