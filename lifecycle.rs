
/*
Rust 生命周期机制是与所有权机制同等重要的资源管理机制。

之所以引入这个概念主要是应对复杂类型系统中资源管理的问题。
引用是对待复杂类型时必不可少的机制，毕竟复杂类型的数据不能被处理器轻易地复制和计算。

*/


// 一直以来我们都在结构体中使用 String 而不用 &str，我们用一个案例解释原因：

// fn longer(s1: &str, s2: &str) -> &str {
//     if s2.len() > s1.len() {
//         s2
//     } else {
//         s1
//     }
// }

// longer 函数取 s1 和 s2 两个字符串切片中较长的一个返回其引用值。
// 但只这段代码不会通过编译，原因是返回值引用可能会返回过期的引用：


/*
生命周期注释

生命周期注释是描述引用生命周期的办法。
虽然这样并不能够改变引用的生命周期，但可以在合适的地方生命两个引用的生命周期一致。
生命收起注释用单引号开头，跟着一个小写字母单词：

*/

// &i32        // 常规引用
// &'a i32     // 含有生命周期注释的引用
// &'a mut i32 // 可变型含有生命周期注释的引用

fn longer<'a>(s1: &'a str, s2: &'a str) -> &'a str {
    if s2.len() > s1.len() {
        s2
    } else {
        s1
    }
}

// 我们需要用泛型声明来规范生命周期的名称，
// 随后函数返回值的生命周期将与两个参数的生命周期一致，所以在调用时可以这样写

fn main() {
    let r;
    {
        let s1 = "rust";
        let s2 = "ecmascript";
        r = longer(s1, s2);
        println!("{} is longer", r);
    }
}
