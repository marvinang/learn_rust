/*
* 智能指针
* 指针（pointer）是一个包含内存地址的变量的通用概念。
* 这个地址引用，或 「指向」（points at）一些其他数据。
* Rust 中最常见的指针是第四章介绍的 引用（reference）。
* 引用以 & 符号为标志并借用了他们所指向的值。
* 除了引用数据没有任何其他特殊功能。
* 它们也没有任何额外开销，所以应用的最多。
*
* 另一方面，智能指针（smart pointers）是一类数据结构，他们的表现类似指针，
* 但是也拥有额外的元数据和功能。
* 智能指针的概念并不为 Rust 所独有；其起源于 C++ 并存在于其他语言中。
* Rust 标准库中不同的智能指针提供了多于引用的额外功能。
*
* 本章将会探索的一个例子便是 引用计数（reference counting）智能指针类型，
* 其允许数据有多个所有者。
* 引用计数智能指针记录总共有多少个所有者，并当没有任何所有者时负责清理数据。
*
* 在 Rust 中，普通引用和智能指针的一个额外的区别是引用是一类只借用数据的指针；
* 相反大部分情况，智能指针 `拥有` 他们指向的数据。
*
* 实际上本书中已经出现过一些智能指针，比如第八章的 String 和 Vec，虽然当时我们并不这么称呼它们。
* 这些类型都属于智能指针因为它们拥有一些数据并允许你修改它们。
* 它们也带有元数据（比如他们的容量）和额外的功能或保证（String 的数据总是有效的 UTF-8 编码）。
*
* 智能指针通常使用结构体实现。
* 智能指针区别于常规结构体的显著特性在于其实现了 Deref 和 Drop trait。
* Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用又用于智能指针的代码。
* Drop trait 允许我们自定义当智能指针离开作用域时运行的代码。
* 本章会讨论这些 trait 以及为什么对于智能指针来说他们很重要。
*
*
* 考虑到智能指针是一个在 Rust 经常被使用的通用设计模式，本章并不会覆盖所有现存的智能指针。
* 很多库都有自己的智能指针而你也可以编写属于你自己的智能指针。这里将会讲到的是来自标准库中最常用的一些：
*  1. Box<T>，用于在堆上分配值
*  2. Rc<T>，一个引用计数类型，其数据可以有多个所有者
*  3. Ref<T> 和 RefMut<T>，通过 RefCell<T> 访问，一个在运行时而不是在编译时执行借用规则的类型。
*
* 另外我们会涉及 内部可变性（interior mutability）模式，这是不可变类型暴露出改变其内部值的 API。
* 我们也会讨论 引用循环（reference cycles）会如何泄露内存，以及如何避免。
*
*/

//========================= Box<T> 指向堆上的数据 =============================
// 最简单直接的智能指针是 box，其类型是 Box<T>
// box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。
//
// 除了数据被储存在堆上而不是栈上之外，box 没有性能损失。不过也没有很多额外的功能。它们多用于如下场景：
//
//  1. 当有一个在编译时未知大小的类型，而又想要在需要确切大小的上下文中使用这个类型值的时候
//  2. 当有大量数据并希望在确保数据不被拷贝的情况下转移所有权的时候
//  3. 当希望拥有一个值并只关心它的类型是否实现了特定 trait 而不是其具体类型的时候
//

//------------------------ Box<T> 在堆上存储数据 --------------------
// 当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。
// 这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）。
fn box_heap() {
    let b = Box::new(5);
    println!("b={}", b);
}

//------------------------ Box<T> 允许创建递归类型 --------------------
// Rust 需要在编译时知道类型占用多少空间。
// 一种无法在编译时知道大小的类型是 递归类型（recursive type），其值的一部分可以是相同类型的另一个值。
// 这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。
// 不过 box 有一个已知的大小，所以通过在循环类型定义中插入 box，就可以创建递归类型了。

//----------------------- cons list ------------------------------------
// 在 Lisp 中，cons 函数（「construct function" 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。
// cons 函数的概念涉及到更通用的函数式编程术语；「将 x 与 y 连接」 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。
// cons list 的每一项都包含两个元素：当前项的值和下一项。
// 其最后一项值包含一个叫做 Nil 的值并没有下一项。
// cons list 通过递归调用 cons 函数产生。代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。
// 注意这不同于第六章中的 「null」 或 「nil」 的概念，他们代表无效或缺失的值。

// Rust 无法计算为了存放 List 值到底需要多少空间。
// 让我们一点一点来看：首先了解一下 Rust 如何决定需要多少空间来存放一个非递归类型。
// enum List {
//     Cons(i32, List),
//     Nil,
// }
//
// 使用 Box 给递归类型一个已知的大小。
// 因为 Box 是一个指针，我们总是知道它需要多少空间：指针的大小并不会根据其指向的数据量而改变。
// 这意味着可以将 Box 放入 Cons 成员中而不是直接存放另一个 List 值。
// Box 会指向另一个位于堆上的 List 值，而不是存放在 Cons 成员中。
// 从概念上讲，我们仍然有一个通过在其中 「存放」 其他列表创建的列表，
// 不过现在实现这个概念的方式更像是一个项挨着另一项，而不是一项包含另一项。

// Cons 成员将会需要一个 i32 的大小加上储存 box 指针数据的空间。
// Nil 成员不储存值，所以它比 Cons 成员需要更少的空间。
// 现在我们知道了任何 List 值最多需要一个 i32 加上 box 指针数据的大小。
// 通过使用 box ，打破了这无限递归的连锁，这样编译器就能够计算出储存 List 值需要的大小了

// box 只提供了间接存储和堆分配；他们并没有任何其他特殊的功能，比如我们将会见到的其他智能指针。
// 它们也没有这些特殊功能带来的性能损失，所以他们可以用于像 cons list 这样间接存储是唯一所需功能的场景。

#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use List::{Cons, Nil};
fn cons_list() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    println!("{:?}", list);
}

// Box 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box 值被当作引用对待。
// 当 Box 值离开作用域时，由于 Box 类型 Drop trait 的实现，box 所指向的堆数据也会被清除。

//====================== 通过 Deref trait 将智能指针当作常规引用处理 ===========
// 实现 Deref trait 允许我们重载`解引用运算符`（dereference operator）*。
// 通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。

// --------------------------- 通过解引用运算符追踪指针的值--------------------------------
// 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头
fn poiter() {
    let x = 5;
    let y = &x;

    assert_eq!(5, x);
    // 然而，如果希望对 y 的值做出断言, 必须使用 *y 来追踪引用所指向的值（也就是 解引用）。
    // 一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较。
    assert_eq!(5, *y);
}

//------------------------ 像引用一样使用 Box ------------------------
fn poiter_box() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

//------------------------- 自定义智能指针 ----------------------------
// 为了体会默认智能指针的行为不同于引用，让我们创建一个类似于标准库提供的 Box 类型的智能指针
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}
// 实现Deref
// 为了实现 trait，需要提供 trait 所需的方法实现。
// Deref trait，由标准库提供，要求实现名为 deref 的方法，其借用 self 并返回一个内部数据的引用
//
// Rust 将 * 运算符替换为先调用 deref 方法再进行直接引用的操作，
// 如此我们便不用担心是不是还需要手动调用 deref 方法了。
// Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 Deref 的类型。

use std::ops::Deref;
impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}

fn poiter_mybox() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    // 这里其实底层运行 *(y.deref())
    assert_eq!(5, *y);
}
//=================================== 函数和方法的隐式解引用 =============================
// 解引用强制多态（deref coercions）是 Rust 表现在函数或方法传参上的一种便利。
// Deref coercions仅对实现了Deref trait上的类型起作用。
// 将这种类型转为对另一种类型的引用。
//
// 比如， &String转为&str, 因为String实现了Deref trait，以便返回str。
// 当传给给函数或方法的引用不匹配定义中的参数类型时，deref coercions会自动执行。
//
// 解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。
// 这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。

fn hello(name: &str) {
    println!("Hello {}", name);
}

fn deref_coercions() {
    let m = MyBox::new(String::from("Rust"));
    // 因为deref coercions，这里会发生自动转换。
    // Rust 可以通过 deref 调用将 &MyBox<String> 变为 &String。
    // 标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。
    // Rust 再次调用 deref 将 &String 变为 &str，这就符合 hello 函数的定义了
    //
    // 当所涉及到的类型定义了 Deref trait，Rust 会分析这些类型并使用任意多次 Deref::deref 调用以获得匹配参数的类型。
    // 这些解析都发生在编译时，所以利用解引用强制多态并没有运行时惩罚！
    hello(&m);

    // 如果没有使用deref coercions
    hello(&(*m)[..]);
}

//--------------------------- Deref coercions 和 mutability 交互 --------------------------
// 类似于如何使用 Deref trait 重载不可变引用的 * 运算符，Rust 提供了 DerefMut trait 用于重载可变引用的 * 运算符。
//
// Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：
// 1. 当 T: Deref<Target=U> 时从 &T 到 &U。
// 2. 当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。
// 3. 当 T: Deref<Target=U> 时从 &mut T 到 &U。
//
// 头两个情况除了可变性之外是相同的：
// 第一种情况表明如果有一个&T，而T实现了返回U类型的Deref，则可以直接得到 &U。
// 第二种情况表明对于可变引用也有着相同的行为。
// 第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。
// 但是反之是不可能的：不可变引用永远也不能强转为可变引用。
// 因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。
// 将一个可变引用转换为不可变引用永远也不会打破借用规则。
// 将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。
// 因此，Rust 无法假设将不可变引用转换为可变引用是可能的。

// =================================== Drop Trait 运行清理代码 =================================
// 对于智能指针模式来说第二个重要的 trait 是 Drop，其允许我们在值要离开作用域时执行一些代码。
// 可以为任何类型提供 Drop trait 的实现，同时所指定的代码被用于释放类似于文件或网络连接的资源。
//
// 我们在智能指针上下文中讨论 Drop 是因为其功能几乎总是用于实现智能指针。
//
// 指定在值离开作用域时应该执行的代码的方式是实现 Drop trait。
// Drop trait 要求实现一个叫做 drop 的方法，它获取一个 self 的可变引用。
// 为了能够看出 Rust 何时调用 drop，让我们暂时使用 println! 语句实现 drop。
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn drop_trait() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointer created");
}
// 当实例离开作用域 Rust 会自动调用 drop，并调用我们指定的代码。
// 变量以被创建时相反的顺序被丢弃，所以 d 在 c 之前被丢弃。

// ------------------------------- 通过 std::mem::drop 提早丢弃值 ---------------------
// 不幸的是，我们并不能直截了当的禁用 drop 这个功能。
// 通常也不需要禁用 drop ，整个 Drop trait 存在的意义在于其是自动处理的。
// 然而，有时你可能需要提早清理某个值。
// 一个例子是当使用智能指针管理锁时；你可能希望强制运行 drop 方法来释放锁以便作用域中的其他代码可以获取锁。
// Rust 并不允许我们主动调用 Drop trait 的 drop 方法；
// 当我们希望在作用域结束之前就强制释放变量的话，我们应该使用的是由标准库提供的 std::mem::drop。
//
// Rust 不允许我们显式调用 drop 因为 Rust 仍然会在 main 的结尾对值自动调用 drop，
// 这会导致一个 double free 错误，因为 Rust 会尝试清理相同的值两次。

// std::mem::drop 函数不同于 Drop trait 中的 drop 方法。可以通过传递希望提早强制丢弃的值作为参数
use std::mem;
fn drop_early() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    println!("early: CustomSmartPointer created");
    mem::drop(c);
    println!("early: CustomSmartPointer dropped before the end of function");
}

// ==================================== Rc<T> 引用计数器智能指针 =============================
// 大部分情况下所有权是非常明确的：可以准确的知道哪个变量拥有某个值。
// 然而，有些情况单个值可能会有多个所有者。
// 例如，在图数据结构中，多个边可能指向相同的结点，而这个结点从概念上讲为所有指向它的边所拥有。
// 结点直到没有任何边指向它之前都不应该被清理。
//
// 为了启用多所有权，Rust 有一个叫做 Rc 的类型。其名称为 引用计数（reference counting）的缩写。
// 引用计数意味着记录一个值引用的数量来知晓这个值是否仍在被使用。如果某个值有零个引用，就代表没有任何有效引用并可以被清理。
//
// Rc 用于当我们希望在堆上分配一些内存供程序的多个部分读取，而且无法在编译时确定程序的那一部分会最后结束使用它的时候。
// 如果确实知道哪部分是最后一个结束使用的话，就可以令其成为数据的所有者同时正常的所有权规则就可以在编译时生效。
//
// 注意 Rc 只能用于单线程场景

// ----------------------------------- 使用 Rc共享数据 -------------------------------------

use std::rc::Rc;
enum List_Rc {
    Cons(i32, Rc<List_Rc>),
    Nil,
}

fn rc_list() {
    let a = Rc::new(List_Rc::Cons(
        5,
        Rc::new(List_Rc::Cons(10, Rc::new(List_Rc::Nil))),
    ));
    // Rc::clone 的实现并不像大部分类型的 clone 实现那样对所有数据进行深拷贝。
    // Rc::clone 只会增加引用计数，这并不会花费多少时间。
    // 深拷贝可能会花费很长时间。
    // 通过使用 Rc::clone 进行引用计数，可以明显的区别深拷贝类的克隆和增加引用计数类的克隆。
    // 当查找代码中的性能问题时，只需考虑深拷贝类的克隆而无需考虑 Rc::clone 调用。
    let b = List_Rc::Cons(3, Rc::clone(&a));
    let c = List_Rc::Cons(4, Rc::clone(&a));
}

// ------------------------------------- Clone 会增加引用计数 ---------------------------
fn rc_clone() {
    let a = Rc::new(List_Rc::Cons(
        5,
        Rc::new(List_Rc::Cons(10, Rc::new(List_Rc::Nil))),
    ));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = List_Rc::Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = List_Rc::Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c get out of scope = {}", Rc::strong_count(&a));
}

// ==================================== RefCell<T> 与内部可变模式 =============================
//  内部可变性（Interior mutability）是 Rust 中的一个设计模式，它允许你即使在有不可变引用时改变数据，
//  这通常是借用规则所不允许的。
//  为了改变数据，该模式在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则。
// 当可以确保代码在运行时会遵守借用规则，即使编译器不能保证的情况，可以选择使用那些运用内部可变性模式的类型。
// 所涉及的 unsafe 代码将被封装进安全的 API 中，而外部类型仍然是不可变的。

// ==================================== 引用循环会泄露内存 =============================

fn main() {
    box_heap();
    cons_list();
    poiter();
    poiter_box();
    poiter_mybox();
    deref_coercions();
    drop_trait();
    drop_early();
    rc_list();
    rc_clone();
}
