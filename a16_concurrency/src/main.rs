/*
 * 并发编程
 * Fearless Concurrency
 *
 * 安全并高效的处理并发编程是 Rust 的另一个主要目标。
 * 并发编程（Concurrent programming），代表程序的不同部分相互独立的执行，
 * 而并行编程（parallel programming）代表程序不同部分于同时执行，
 * 这两个概念随着计算机越来越多的利用多处理器的优势时显得愈发重要。
 * 由于历史原因，在此类上下文中编程一直是困难且容易出错的：
 * Rust 希望能改变这一点。
 *
 * 起初，Rust 团队认为确保内存安全和防止并发问题是两个分别需要不同方法应对的挑战。
 * 随着时间的推移，团队发现所有权和类型系统是一系列解决内存安全 和 并发问题的强有力的工具！
 * 通过利用所有权和类型检查，在 Rust 中很多并发错误都是 编译时 错误，
 * 而非运行时错误。
 * 因此，相比花费大量时间尝试重现运行时并发 bug 出现的特定情况，
 * Rust 会拒绝编译不正确的代码并提供解释问题的错误信息。
 * 因此，你可以在开发时修复代码，而不是在部署到生产环境后修复代码。
 * 我们给 Rust 的这一部分起了一个绰号 无畏并发（fearless concurrency）。
 * 无畏并发令你的代码免于出现诡异的 bug 并可以轻松重构且无需担心会引入新的 bug。
 */

// ====================== 使用线程 ===================================
/*
在大部分现代操作系统中，执行中程序的代码运行于一个 进程（process）中，操作系统则负责管理多个进程。
在程序内部，也可以拥有多个同时运行的独立部分。这个运行这些独立部分的功能被称为 线程（threads）。

将程序中的计算拆分进多个线程可以改善性能，因为程序可以同时进行多个任务，不过这也会增加复杂性。
因为线程是同时运行的，所以无法预先保证不同线程中的代码的执行顺序。这会导致诸如此类的问题：
  1. 竞争状态（Race conditions），多个线程以不一致的顺序访问数据或资源
  2. 死锁（Deadlocks），两个线程相互等待对方停止使用其所拥有的资源，这会阻止它们继续运行
  3. 只会发生在特定情况且难以稳定重现和修复的 bug

Rust 尝试缓和使用线程的负面影响。不过在多线程上下文中编程仍需格外小心，同时其所要求的代码结构也不同于运行于单线程的程序。

编程语言有一些不同的方法来实现线程。
很多操作系统提供了创建新线程的 API。
这种由编程语言调用操作系统 API 创建线程的模型有时被称为 1:1，一个 OS 线程对应一个语言线程。

很多编程语言提供了自己特殊的线程实现。
编程语言提供的线程被称为 绿色（green）线程，使用绿色线程的语言会在不同数量的 OS 线程的上下文中执行它们。
为此，绿色线程模式被称为 M:N 模型：M 个绿色线程对应 N 个 OS 线程，这里 M 和 N 不必相同。

每一个模型都有其优势和取舍。对于 Rust 来说最重要的取舍是运行时支持。
运行时（Runtime）是一个令人迷惑的概念，其在不同上下文中可能有不同的含义。

在当前上下文中，运行时代表二进制文件中包含的由语言自身提供的代码。
这些代码根据语言的不同可大可小，不过任何非汇编语言都会有一定数量的运行时代码。
为此，通常人们说一个语言 “没有运行时”，一般意味着 “小运行时”。
更小的运行时拥有更少的功能不过其优势在于更小的二进制输出，这使其易于在更多上下文中与其他语言相结合。
虽然很多语言觉得增加运行时来换取更多功能没有什么问题，但是 Rust 需要做到几乎没有运行时，
同时为了保持高性能必需能够调用 C 语言，这点也是不能妥协的。

绿色线程的 M:N 模型需要更大的语言运行时来管理这些线程。
因此，Rust 标准库只提供了 1:1 线程模型实现。
由于 Rust 是较为底层的语言，如果你愿意牺牲性能来换取的抽象，
以获得对线程运行更精细的控制及更低的上下文切换成本，你可以使用实现了 M:N 线程模型的 crate。

现在我们明白了 Rust 中的线程是如何定义的，让我们开始探索如何使用标准库提供的线程相关的 API 吧。

*/

// ----------------------- 使用 spawn 创建线程 -----------------------
use std::thread;
use std::time::Duration;

fn spawn_thread() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("hi, number {} from spawned thread", i);
            thread::sleep(Duration::from_millis(10));
        }
    });
    for i in 1..5 {
        println!("hi, number {} from the main thread", i);
        thread::sleep(Duration::from_millis(10));
    }
}

//------------------------ 使用join等待所有线程结束-----------
// thread::spawn 的返回值类型是 JoinHandle。
// JoinHandle 是一个拥有所有权的值，当对其调用 join 方法时，它会等待其线程结束
fn join_thread() {
    println!("============= join_thread() ==========");
    let handler = thread::spawn(|| {
        for i in 1..10 {
            println!("hi, number {} from spawned thread", i);
            thread::sleep(Duration::from_millis(10));
        }
    });
    for i in 1..5 {
        println!("hi, number {} from the main thread", i);
        thread::sleep(Duration::from_millis(10));
    }
    handler.join().unwrap();
}

//------------------------ 线程和move闭包 -----------
// move 闭包，我们曾在第十三章简要的提到过，其经常与 thread::spawn 一起使用，
// 因为它允许我们在一个线程中使用另一个线程的数据。
//
// 第十三章讲到如果可以在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权。
// 这个技巧在将闭包传递给新线程以便将数据移动到新线程中时最为实用。
fn move_thread() {
    println!("================ move_thread ===========");
    let v = vec![1, 2, 3];
    // 闭包使用了 v，所以闭包会捕获 v 并使其成为闭包环境的一部分。
    // 因为 thread::spawn 在一个新线程中运行这个闭包，所以可以在新线程中访问 v。然而当编译这个例子时，会得到错误：
    //
    // Rust 会 推断 如何捕获 v，因为 println! 只需要 v 的引用，闭包尝试借用 v。
    // 然而这有一个问题：Rust 不知道这个新建线程会执行多久，所以无法知晓 v 的引用是否一直有效。
    //
    // 通过在闭包之前增加 move 关键字，我们强制闭包获取其使用的值的所有权，而不是任由 Rust 推断它应该借用值
    let handle = thread::spawn(move || {
        println!("here's a vector: {:?}", v);
    });
    // drop(v);
    handle.join().unwrap();
}

// ===================== 使用消息传递在线程之间传递数据 ===================================
// 一个日益流行的确保安全并发的方式是 消息传递（message passing），这里线程或 actor 通过发送包含数据的消息来相互沟通。
// 这个思想来源于 Go 编程语言文档中 的口号：
// “不要共享内存来通讯；而是要通讯来共享内存。”（“Do not communicate by sharing memory; instead, share memory by communicating.”）

// Rust 中一个实现消息传递并发的主要工具是 通道（channel），一个 Rust 标准库提供了其实现的编程概念。
// 编程中的通道有两部分组成，一个发送者（transmitter）和一个接收者（receiver）。
// 代码中的一部分调用发送者的方法以及希望发送的数据，另一部分则检查接收端收到到达的消息。
// 当发送者或接收者任一被丢弃时可以认为通道被 关闭（closed）了

// ----------------------- 使用 mpsc ------------------------
//
// 这里使用 mpsc::channel 函数创建一个新的通道；
// mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）的缩写。
// 简而言之，Rust 标准库实现通道的方式意味着一个通道可以有多个产生值的 发送（sending）端，
// 但只能有一个消费这些值的 接收（receiving）端。
// 想象一下多条小河小溪最终汇聚成大河：所有通过这些小河发出的东西最后都会来到大河的下游。
// 目前我们以单个生产者开始，但是当示例可以工作后会增加多个生产者。
//
// mpsc::channel 函数返回一个元组：第一个元素是发送端，而第二个元素是接收端。
// 由于历史原因，tx 和 rx 通常作为 发送者（transmitter）和 接收者（receiver）的缩写，
// 所以这就是我们将用来绑定这两端变量的名字。
// 这里使用了一个 let 语句和模式来解构了此元组；
// 第十八章会讨论 let 语句中的模式和解构。
// 如此使用 let 语句是一个方便提取 mpsc::channel 返回的元组中一部分的手段。
use std::sync::mpsc;
fn channel_one_one() {
    println!("============== channel_one_one ===================");
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        // 通道的发送端有一个 send 方法用来获取需要放入通道的值。
        // send 方法返回一个 Result<T, E> 类型，所以如果接收端已经被丢弃了，
        // 将没有发送值的目标，所以发送操作会返回错误。
        // 在这个例子中，出错的时候调用 unwrap 产生 panic。
        // 不过对于一个真实程序，需要合理地处理它
        tx.send(val).unwrap();
    });

    // 通道的接收端有两个有用的方法：recv 和 try_recv。
    // 这里，我们使用了 recv，它是 receive 的缩写。
    // 这个方法会阻塞主线程执行直到从通道中接收一个值。
    // 一旦发送了一个值，recv 会在一个 Result<T, E> 中返回它。
    // 当通道发送端关闭，recv 会返回一个错误表明不会再有新的值到来了。

    // try_recv 不会阻塞，相反它立刻返回一个 Result<T, E>：Ok 值包含可用的信息，而 Err 值代表此时没有任何消息。
    // 如果线程在等待消息过程中还有其他工作时使用 try_recv 很有用：
    // 可以编写一个循环来频繁调用 try_recv，再有可用消息时进行处理，其余时候则处理一会其他工作直到再次检查。

    // 出于简单的考虑，这个例子使用了 recv；
    // 主线程中除了等待消息之外没有任何其他工作，所以阻塞主线程是合适的。
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}

// ---------------------------- 通道与所有权转移 ------------------------------
// 所有权规则在消息传递中扮演了重要角色，其有助于我们编写安全的并发代码。
// 在并发编程中避免错误是在整个 Rust 程序中必须思考所有权所换来的一大优势。
// 现在让我们做一个试验来看看通道与所有权如何一同协作以避免产生问题：
// 我们将尝试在新建线程中的通道中发送完 val 值 之后 再使用它
//
// send 函数获取其参数的所有权并移动这个值归接收者所有。
// 这个意味着不可能意外的在发送后再次使用这个值；所有权系统检查一切是否合乎规则。
fn channel_ownership() {
    println!("=================== channel_ownership ==========");
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
        // 这里val的所有权会被转移走，后面不能再次访问了
        // println!("val is {}", val);
    });
    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}

// ------------------------- 发送多个值并且观察接受者的等待 ------------------
fn channel_more_value() {
    println!("=================== channel_more_value ==========");
    let (tx, rx) = mpsc::channel();
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    // 在主线程中，不再显式调用 recv 函数：而是将 rx 当作一个迭代器。
    // 对于每一个接收到的值，我们将其打印出来。
    // 当通道被关闭时，迭代器也将结束。
    //
    // 因为主线程中的 for 循环里并没有任何暂停或等待的代码，所以可以说主线程是在等待从新建线程中接收值。
    for received in rx {
        println!("Got: {}", received);
    }
}

// ----------------------- 通过克隆发送者来创建多个生产者 -------------------------------
// 可以运用 mpsc 来扩展示例中的代码来以创建都向同一接收者发送值的多个线程。
// 这可以通过克隆通道的发送端在来做到。
fn channel_multi_one() {
    println!("==================== channel_multi_one =================");
    let (tx, rx) = mpsc::channel();
    // 这一次，在创建新线程之前，我们对通道的发送端调用了 clone 方法。
    // 这会给我们一个可以传递给第一个新建线程的发送端句柄。
    // 我们会将原始的通道发送端传递给第二个新建线程。
    // 这样就会有两个线程，每个线程将向通道的接收端发送不同的消息。
    let tx1 = mpsc::Sender::clone(&tx);
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        for val in vals {
            tx1.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });
    for received in rx {
        println!("Got: {}", received);
    }
}

// ================================= 共享状态并发 ==============================
// 在某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。
// 共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。
// 第十五章介绍了智能指针如何使得多所有权成为可能，然而这会增加额外的复杂性，因为需要以某种方式管理这些不同的所有者。
// Rust 的类型系统和所有权规则极大的协助了正确地管理这些所有权。
// 作为一个例子，让我们看看互斥器，一个更为常见的共享内存并发原语。

// ------------------------- 互斥器， 一次只允许一个线程访问数据 ---------------
// 互斥器（mutex）是 mutual exclusion 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。
// 为了访问互斥器中的数据，线程首先需要通过获取互斥器的 锁（lock）来表明其希望访问数据。
// 锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。
// 因此，我们描述互斥器为通过锁系统 保护（guarding）其数据。
//
// 互斥器以难以使用著称，因为你不得不记住：
//  1. 在使用数据之前尝试获取锁。
//  2. 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。
//
// 正确的管理互斥器异常复杂，这也是许多人之所以热衷于通道的原因。
// 然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。

// ------------------- Mutex<T> API ----------------
// 像很多类型一样，我们使用关联函数 new 来创建一个 Mutex<T>。
// 使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。

// 如果另一个线程拥有锁，并且那个线程 panic 了，则 lock 调用会失败。
// 在这种情况下，没人能够再获取锁，所以这里选择 unwrap 并在遇到这种情况时使线程 panic。

// 一旦获取了锁，就可以将返回值（在这里是num）视为一个其内部数据的可变引用了。
// 类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 必须 获取锁才能使用这个 i32 值。
// 我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。

// 正如你所怀疑的，Mutex<T> 是一个智能指针。
// 更准确的说，lock 调用 返回 一个叫做 MutexGuard 的智能指针。
// 这个智能指针实现了 Deref 来指向其内部数据；其也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，
// 这正发生于示例内部作用域的结尾。
// 为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。

// 丢弃了锁之后，可以打印出互斥器的值，并发现能够将其内部的 i32 改为 6。
use std::sync::Mutex;
fn mutex() {
    println!("================== mutext() =================");
    let m = Mutex::new(5);
    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }
    println!("m = {:?}", m);
}

// ----------------- 线程之间共享 Mutex<T> -----------------------
//
// 多线程和多所有权
//
// 在第十五章中，通过使用智能指针 Rc<T> 来创建引用计数的值，以便拥有多所有者。让我们在这也这么做看看会发生什么。
//
// 不幸的是，Rc<T> 并不能安全的在线程间共享。当 Rc<T> 管理引用计数时，它必须在每一个 clone调用时增加计数，
// 并在每一个克隆被丢弃时减少计数。
// Rc<T>并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断。
// 在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。
// 我们所需要的是一个完全类似Rc<T>，又以一种线程安全的方式改变引用计数的类0
//
// ------- 原子引用计数 Arc<T> -----------
// 所幸 Arc<T> 正是 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。
// 字母 “a” 代表 原子性（atomic），所以这是一个原子引用计数（atomically reference counted）类型。
// 原子性是另一类这里还未涉及到的并发原语：请查看标准库中 std::sync::atomic 的文档来获取更多细节。
// 其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。

// 你可能会好奇为什么不是所有的原始类型都是原子性的？
// 为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？
// 原因在于线程安全带有性能惩罚，我们希望只在必要时才为此买单。
// 如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。
use std::sync::Arc;
fn mutext_threads() {
    println!("================== mutext_threads() =================");
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10 {
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());
}

// --------------------------- RefCell<T>/Rc<T> 与 Mutex<T>/Arc<T>的相似性 --------------
// 你可能注意到了，因为 counter 是不可变的，不过可以获取其内部值的可变引用；
// 这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。
// 正如第十五章中使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，
// 同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。

// 另一个值得注意的细节是 Rust 不能避免使用 Mutex<T> 的全部逻辑错误。
// 回忆一下第十五章使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄露。
// 同理，Mutex<T> 也有造成 死锁（deadlock） 的风险。
// 这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。
// 如果你对这个主题感兴趣，尝试编写一个带有死锁的 Rust 程序，
// 接着研究任何其他语言中使用互斥器的死锁规避策略并尝试在 Rust 中实现他们。
// 标准库中 Mutex<T> 和 MutexGuard 的 API 文档会提供有用的信息。

// ===================== 使用Sync 和 Send trait 的可扩展并发 =======================
//
//

fn main() {
    spawn_thread();
    join_thread();
    move_thread();
    channel_one_one();
    channel_more_value();
    channel_multi_one();

    mutex();
    mutext_threads();
}
